// Code generated by counterfeiter. DO NOT EDIT.
package fakes

import (
	"context"
	"sync"

	v1 "github.com/authzed/authzed-go/proto/authzed/api/v1"
	"github.com/ben-mays/go-migrate-spicedb/client"
	"google.golang.org/grpc"
)

type FakeClient struct {
	CheckPermissionStub        func(context.Context, *v1.CheckPermissionRequest, ...grpc.CallOption) (*v1.CheckPermissionResponse, error)
	checkPermissionMutex       sync.RWMutex
	checkPermissionArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.CheckPermissionRequest
		arg3 []grpc.CallOption
	}
	checkPermissionReturns struct {
		result1 *v1.CheckPermissionResponse
		result2 error
	}
	checkPermissionReturnsOnCall map[int]struct {
		result1 *v1.CheckPermissionResponse
		result2 error
	}
	DeleteRelationshipsStub        func(context.Context, *v1.DeleteRelationshipsRequest, ...grpc.CallOption) (*v1.DeleteRelationshipsResponse, error)
	deleteRelationshipsMutex       sync.RWMutex
	deleteRelationshipsArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.DeleteRelationshipsRequest
		arg3 []grpc.CallOption
	}
	deleteRelationshipsReturns struct {
		result1 *v1.DeleteRelationshipsResponse
		result2 error
	}
	deleteRelationshipsReturnsOnCall map[int]struct {
		result1 *v1.DeleteRelationshipsResponse
		result2 error
	}
	ExpandPermissionTreeStub        func(context.Context, *v1.ExpandPermissionTreeRequest, ...grpc.CallOption) (*v1.ExpandPermissionTreeResponse, error)
	expandPermissionTreeMutex       sync.RWMutex
	expandPermissionTreeArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.ExpandPermissionTreeRequest
		arg3 []grpc.CallOption
	}
	expandPermissionTreeReturns struct {
		result1 *v1.ExpandPermissionTreeResponse
		result2 error
	}
	expandPermissionTreeReturnsOnCall map[int]struct {
		result1 *v1.ExpandPermissionTreeResponse
		result2 error
	}
	LookupResourcesStub        func(context.Context, *v1.LookupResourcesRequest, ...grpc.CallOption) (v1.PermissionsService_LookupResourcesClient, error)
	lookupResourcesMutex       sync.RWMutex
	lookupResourcesArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.LookupResourcesRequest
		arg3 []grpc.CallOption
	}
	lookupResourcesReturns struct {
		result1 v1.PermissionsService_LookupResourcesClient
		result2 error
	}
	lookupResourcesReturnsOnCall map[int]struct {
		result1 v1.PermissionsService_LookupResourcesClient
		result2 error
	}
	LookupSubjectsStub        func(context.Context, *v1.LookupSubjectsRequest, ...grpc.CallOption) (v1.PermissionsService_LookupSubjectsClient, error)
	lookupSubjectsMutex       sync.RWMutex
	lookupSubjectsArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.LookupSubjectsRequest
		arg3 []grpc.CallOption
	}
	lookupSubjectsReturns struct {
		result1 v1.PermissionsService_LookupSubjectsClient
		result2 error
	}
	lookupSubjectsReturnsOnCall map[int]struct {
		result1 v1.PermissionsService_LookupSubjectsClient
		result2 error
	}
	ReadRelationshipsStub        func(context.Context, *v1.ReadRelationshipsRequest, ...grpc.CallOption) (v1.PermissionsService_ReadRelationshipsClient, error)
	readRelationshipsMutex       sync.RWMutex
	readRelationshipsArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.ReadRelationshipsRequest
		arg3 []grpc.CallOption
	}
	readRelationshipsReturns struct {
		result1 v1.PermissionsService_ReadRelationshipsClient
		result2 error
	}
	readRelationshipsReturnsOnCall map[int]struct {
		result1 v1.PermissionsService_ReadRelationshipsClient
		result2 error
	}
	ReadSchemaStub        func(context.Context, *v1.ReadSchemaRequest, ...grpc.CallOption) (*v1.ReadSchemaResponse, error)
	readSchemaMutex       sync.RWMutex
	readSchemaArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.ReadSchemaRequest
		arg3 []grpc.CallOption
	}
	readSchemaReturns struct {
		result1 *v1.ReadSchemaResponse
		result2 error
	}
	readSchemaReturnsOnCall map[int]struct {
		result1 *v1.ReadSchemaResponse
		result2 error
	}
	WatchStub        func(context.Context, *v1.WatchRequest, ...grpc.CallOption) (v1.WatchService_WatchClient, error)
	watchMutex       sync.RWMutex
	watchArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.WatchRequest
		arg3 []grpc.CallOption
	}
	watchReturns struct {
		result1 v1.WatchService_WatchClient
		result2 error
	}
	watchReturnsOnCall map[int]struct {
		result1 v1.WatchService_WatchClient
		result2 error
	}
	WriteRelationshipsStub        func(context.Context, *v1.WriteRelationshipsRequest, ...grpc.CallOption) (*v1.WriteRelationshipsResponse, error)
	writeRelationshipsMutex       sync.RWMutex
	writeRelationshipsArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.WriteRelationshipsRequest
		arg3 []grpc.CallOption
	}
	writeRelationshipsReturns struct {
		result1 *v1.WriteRelationshipsResponse
		result2 error
	}
	writeRelationshipsReturnsOnCall map[int]struct {
		result1 *v1.WriteRelationshipsResponse
		result2 error
	}
	WriteSchemaStub        func(context.Context, *v1.WriteSchemaRequest, ...grpc.CallOption) (*v1.WriteSchemaResponse, error)
	writeSchemaMutex       sync.RWMutex
	writeSchemaArgsForCall []struct {
		arg1 context.Context
		arg2 *v1.WriteSchemaRequest
		arg3 []grpc.CallOption
	}
	writeSchemaReturns struct {
		result1 *v1.WriteSchemaResponse
		result2 error
	}
	writeSchemaReturnsOnCall map[int]struct {
		result1 *v1.WriteSchemaResponse
		result2 error
	}
	invocations      map[string][][]interface{}
	invocationsMutex sync.RWMutex
}

func (fake *FakeClient) CheckPermission(arg1 context.Context, arg2 *v1.CheckPermissionRequest, arg3 ...grpc.CallOption) (*v1.CheckPermissionResponse, error) {
	fake.checkPermissionMutex.Lock()
	ret, specificReturn := fake.checkPermissionReturnsOnCall[len(fake.checkPermissionArgsForCall)]
	fake.checkPermissionArgsForCall = append(fake.checkPermissionArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.CheckPermissionRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.CheckPermissionStub
	fakeReturns := fake.checkPermissionReturns
	fake.recordInvocation("CheckPermission", []interface{}{arg1, arg2, arg3})
	fake.checkPermissionMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) CheckPermissionCallCount() int {
	fake.checkPermissionMutex.RLock()
	defer fake.checkPermissionMutex.RUnlock()
	return len(fake.checkPermissionArgsForCall)
}

func (fake *FakeClient) CheckPermissionCalls(stub func(context.Context, *v1.CheckPermissionRequest, ...grpc.CallOption) (*v1.CheckPermissionResponse, error)) {
	fake.checkPermissionMutex.Lock()
	defer fake.checkPermissionMutex.Unlock()
	fake.CheckPermissionStub = stub
}

func (fake *FakeClient) CheckPermissionArgsForCall(i int) (context.Context, *v1.CheckPermissionRequest, []grpc.CallOption) {
	fake.checkPermissionMutex.RLock()
	defer fake.checkPermissionMutex.RUnlock()
	argsForCall := fake.checkPermissionArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) CheckPermissionReturns(result1 *v1.CheckPermissionResponse, result2 error) {
	fake.checkPermissionMutex.Lock()
	defer fake.checkPermissionMutex.Unlock()
	fake.CheckPermissionStub = nil
	fake.checkPermissionReturns = struct {
		result1 *v1.CheckPermissionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) CheckPermissionReturnsOnCall(i int, result1 *v1.CheckPermissionResponse, result2 error) {
	fake.checkPermissionMutex.Lock()
	defer fake.checkPermissionMutex.Unlock()
	fake.CheckPermissionStub = nil
	if fake.checkPermissionReturnsOnCall == nil {
		fake.checkPermissionReturnsOnCall = make(map[int]struct {
			result1 *v1.CheckPermissionResponse
			result2 error
		})
	}
	fake.checkPermissionReturnsOnCall[i] = struct {
		result1 *v1.CheckPermissionResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteRelationships(arg1 context.Context, arg2 *v1.DeleteRelationshipsRequest, arg3 ...grpc.CallOption) (*v1.DeleteRelationshipsResponse, error) {
	fake.deleteRelationshipsMutex.Lock()
	ret, specificReturn := fake.deleteRelationshipsReturnsOnCall[len(fake.deleteRelationshipsArgsForCall)]
	fake.deleteRelationshipsArgsForCall = append(fake.deleteRelationshipsArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.DeleteRelationshipsRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.DeleteRelationshipsStub
	fakeReturns := fake.deleteRelationshipsReturns
	fake.recordInvocation("DeleteRelationships", []interface{}{arg1, arg2, arg3})
	fake.deleteRelationshipsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) DeleteRelationshipsCallCount() int {
	fake.deleteRelationshipsMutex.RLock()
	defer fake.deleteRelationshipsMutex.RUnlock()
	return len(fake.deleteRelationshipsArgsForCall)
}

func (fake *FakeClient) DeleteRelationshipsCalls(stub func(context.Context, *v1.DeleteRelationshipsRequest, ...grpc.CallOption) (*v1.DeleteRelationshipsResponse, error)) {
	fake.deleteRelationshipsMutex.Lock()
	defer fake.deleteRelationshipsMutex.Unlock()
	fake.DeleteRelationshipsStub = stub
}

func (fake *FakeClient) DeleteRelationshipsArgsForCall(i int) (context.Context, *v1.DeleteRelationshipsRequest, []grpc.CallOption) {
	fake.deleteRelationshipsMutex.RLock()
	defer fake.deleteRelationshipsMutex.RUnlock()
	argsForCall := fake.deleteRelationshipsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) DeleteRelationshipsReturns(result1 *v1.DeleteRelationshipsResponse, result2 error) {
	fake.deleteRelationshipsMutex.Lock()
	defer fake.deleteRelationshipsMutex.Unlock()
	fake.DeleteRelationshipsStub = nil
	fake.deleteRelationshipsReturns = struct {
		result1 *v1.DeleteRelationshipsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) DeleteRelationshipsReturnsOnCall(i int, result1 *v1.DeleteRelationshipsResponse, result2 error) {
	fake.deleteRelationshipsMutex.Lock()
	defer fake.deleteRelationshipsMutex.Unlock()
	fake.DeleteRelationshipsStub = nil
	if fake.deleteRelationshipsReturnsOnCall == nil {
		fake.deleteRelationshipsReturnsOnCall = make(map[int]struct {
			result1 *v1.DeleteRelationshipsResponse
			result2 error
		})
	}
	fake.deleteRelationshipsReturnsOnCall[i] = struct {
		result1 *v1.DeleteRelationshipsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ExpandPermissionTree(arg1 context.Context, arg2 *v1.ExpandPermissionTreeRequest, arg3 ...grpc.CallOption) (*v1.ExpandPermissionTreeResponse, error) {
	fake.expandPermissionTreeMutex.Lock()
	ret, specificReturn := fake.expandPermissionTreeReturnsOnCall[len(fake.expandPermissionTreeArgsForCall)]
	fake.expandPermissionTreeArgsForCall = append(fake.expandPermissionTreeArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.ExpandPermissionTreeRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ExpandPermissionTreeStub
	fakeReturns := fake.expandPermissionTreeReturns
	fake.recordInvocation("ExpandPermissionTree", []interface{}{arg1, arg2, arg3})
	fake.expandPermissionTreeMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ExpandPermissionTreeCallCount() int {
	fake.expandPermissionTreeMutex.RLock()
	defer fake.expandPermissionTreeMutex.RUnlock()
	return len(fake.expandPermissionTreeArgsForCall)
}

func (fake *FakeClient) ExpandPermissionTreeCalls(stub func(context.Context, *v1.ExpandPermissionTreeRequest, ...grpc.CallOption) (*v1.ExpandPermissionTreeResponse, error)) {
	fake.expandPermissionTreeMutex.Lock()
	defer fake.expandPermissionTreeMutex.Unlock()
	fake.ExpandPermissionTreeStub = stub
}

func (fake *FakeClient) ExpandPermissionTreeArgsForCall(i int) (context.Context, *v1.ExpandPermissionTreeRequest, []grpc.CallOption) {
	fake.expandPermissionTreeMutex.RLock()
	defer fake.expandPermissionTreeMutex.RUnlock()
	argsForCall := fake.expandPermissionTreeArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ExpandPermissionTreeReturns(result1 *v1.ExpandPermissionTreeResponse, result2 error) {
	fake.expandPermissionTreeMutex.Lock()
	defer fake.expandPermissionTreeMutex.Unlock()
	fake.ExpandPermissionTreeStub = nil
	fake.expandPermissionTreeReturns = struct {
		result1 *v1.ExpandPermissionTreeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ExpandPermissionTreeReturnsOnCall(i int, result1 *v1.ExpandPermissionTreeResponse, result2 error) {
	fake.expandPermissionTreeMutex.Lock()
	defer fake.expandPermissionTreeMutex.Unlock()
	fake.ExpandPermissionTreeStub = nil
	if fake.expandPermissionTreeReturnsOnCall == nil {
		fake.expandPermissionTreeReturnsOnCall = make(map[int]struct {
			result1 *v1.ExpandPermissionTreeResponse
			result2 error
		})
	}
	fake.expandPermissionTreeReturnsOnCall[i] = struct {
		result1 *v1.ExpandPermissionTreeResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) LookupResources(arg1 context.Context, arg2 *v1.LookupResourcesRequest, arg3 ...grpc.CallOption) (v1.PermissionsService_LookupResourcesClient, error) {
	fake.lookupResourcesMutex.Lock()
	ret, specificReturn := fake.lookupResourcesReturnsOnCall[len(fake.lookupResourcesArgsForCall)]
	fake.lookupResourcesArgsForCall = append(fake.lookupResourcesArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.LookupResourcesRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.LookupResourcesStub
	fakeReturns := fake.lookupResourcesReturns
	fake.recordInvocation("LookupResources", []interface{}{arg1, arg2, arg3})
	fake.lookupResourcesMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) LookupResourcesCallCount() int {
	fake.lookupResourcesMutex.RLock()
	defer fake.lookupResourcesMutex.RUnlock()
	return len(fake.lookupResourcesArgsForCall)
}

func (fake *FakeClient) LookupResourcesCalls(stub func(context.Context, *v1.LookupResourcesRequest, ...grpc.CallOption) (v1.PermissionsService_LookupResourcesClient, error)) {
	fake.lookupResourcesMutex.Lock()
	defer fake.lookupResourcesMutex.Unlock()
	fake.LookupResourcesStub = stub
}

func (fake *FakeClient) LookupResourcesArgsForCall(i int) (context.Context, *v1.LookupResourcesRequest, []grpc.CallOption) {
	fake.lookupResourcesMutex.RLock()
	defer fake.lookupResourcesMutex.RUnlock()
	argsForCall := fake.lookupResourcesArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) LookupResourcesReturns(result1 v1.PermissionsService_LookupResourcesClient, result2 error) {
	fake.lookupResourcesMutex.Lock()
	defer fake.lookupResourcesMutex.Unlock()
	fake.LookupResourcesStub = nil
	fake.lookupResourcesReturns = struct {
		result1 v1.PermissionsService_LookupResourcesClient
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) LookupResourcesReturnsOnCall(i int, result1 v1.PermissionsService_LookupResourcesClient, result2 error) {
	fake.lookupResourcesMutex.Lock()
	defer fake.lookupResourcesMutex.Unlock()
	fake.LookupResourcesStub = nil
	if fake.lookupResourcesReturnsOnCall == nil {
		fake.lookupResourcesReturnsOnCall = make(map[int]struct {
			result1 v1.PermissionsService_LookupResourcesClient
			result2 error
		})
	}
	fake.lookupResourcesReturnsOnCall[i] = struct {
		result1 v1.PermissionsService_LookupResourcesClient
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) LookupSubjects(arg1 context.Context, arg2 *v1.LookupSubjectsRequest, arg3 ...grpc.CallOption) (v1.PermissionsService_LookupSubjectsClient, error) {
	fake.lookupSubjectsMutex.Lock()
	ret, specificReturn := fake.lookupSubjectsReturnsOnCall[len(fake.lookupSubjectsArgsForCall)]
	fake.lookupSubjectsArgsForCall = append(fake.lookupSubjectsArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.LookupSubjectsRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.LookupSubjectsStub
	fakeReturns := fake.lookupSubjectsReturns
	fake.recordInvocation("LookupSubjects", []interface{}{arg1, arg2, arg3})
	fake.lookupSubjectsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) LookupSubjectsCallCount() int {
	fake.lookupSubjectsMutex.RLock()
	defer fake.lookupSubjectsMutex.RUnlock()
	return len(fake.lookupSubjectsArgsForCall)
}

func (fake *FakeClient) LookupSubjectsCalls(stub func(context.Context, *v1.LookupSubjectsRequest, ...grpc.CallOption) (v1.PermissionsService_LookupSubjectsClient, error)) {
	fake.lookupSubjectsMutex.Lock()
	defer fake.lookupSubjectsMutex.Unlock()
	fake.LookupSubjectsStub = stub
}

func (fake *FakeClient) LookupSubjectsArgsForCall(i int) (context.Context, *v1.LookupSubjectsRequest, []grpc.CallOption) {
	fake.lookupSubjectsMutex.RLock()
	defer fake.lookupSubjectsMutex.RUnlock()
	argsForCall := fake.lookupSubjectsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) LookupSubjectsReturns(result1 v1.PermissionsService_LookupSubjectsClient, result2 error) {
	fake.lookupSubjectsMutex.Lock()
	defer fake.lookupSubjectsMutex.Unlock()
	fake.LookupSubjectsStub = nil
	fake.lookupSubjectsReturns = struct {
		result1 v1.PermissionsService_LookupSubjectsClient
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) LookupSubjectsReturnsOnCall(i int, result1 v1.PermissionsService_LookupSubjectsClient, result2 error) {
	fake.lookupSubjectsMutex.Lock()
	defer fake.lookupSubjectsMutex.Unlock()
	fake.LookupSubjectsStub = nil
	if fake.lookupSubjectsReturnsOnCall == nil {
		fake.lookupSubjectsReturnsOnCall = make(map[int]struct {
			result1 v1.PermissionsService_LookupSubjectsClient
			result2 error
		})
	}
	fake.lookupSubjectsReturnsOnCall[i] = struct {
		result1 v1.PermissionsService_LookupSubjectsClient
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ReadRelationships(arg1 context.Context, arg2 *v1.ReadRelationshipsRequest, arg3 ...grpc.CallOption) (v1.PermissionsService_ReadRelationshipsClient, error) {
	fake.readRelationshipsMutex.Lock()
	ret, specificReturn := fake.readRelationshipsReturnsOnCall[len(fake.readRelationshipsArgsForCall)]
	fake.readRelationshipsArgsForCall = append(fake.readRelationshipsArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.ReadRelationshipsRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ReadRelationshipsStub
	fakeReturns := fake.readRelationshipsReturns
	fake.recordInvocation("ReadRelationships", []interface{}{arg1, arg2, arg3})
	fake.readRelationshipsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ReadRelationshipsCallCount() int {
	fake.readRelationshipsMutex.RLock()
	defer fake.readRelationshipsMutex.RUnlock()
	return len(fake.readRelationshipsArgsForCall)
}

func (fake *FakeClient) ReadRelationshipsCalls(stub func(context.Context, *v1.ReadRelationshipsRequest, ...grpc.CallOption) (v1.PermissionsService_ReadRelationshipsClient, error)) {
	fake.readRelationshipsMutex.Lock()
	defer fake.readRelationshipsMutex.Unlock()
	fake.ReadRelationshipsStub = stub
}

func (fake *FakeClient) ReadRelationshipsArgsForCall(i int) (context.Context, *v1.ReadRelationshipsRequest, []grpc.CallOption) {
	fake.readRelationshipsMutex.RLock()
	defer fake.readRelationshipsMutex.RUnlock()
	argsForCall := fake.readRelationshipsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ReadRelationshipsReturns(result1 v1.PermissionsService_ReadRelationshipsClient, result2 error) {
	fake.readRelationshipsMutex.Lock()
	defer fake.readRelationshipsMutex.Unlock()
	fake.ReadRelationshipsStub = nil
	fake.readRelationshipsReturns = struct {
		result1 v1.PermissionsService_ReadRelationshipsClient
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ReadRelationshipsReturnsOnCall(i int, result1 v1.PermissionsService_ReadRelationshipsClient, result2 error) {
	fake.readRelationshipsMutex.Lock()
	defer fake.readRelationshipsMutex.Unlock()
	fake.ReadRelationshipsStub = nil
	if fake.readRelationshipsReturnsOnCall == nil {
		fake.readRelationshipsReturnsOnCall = make(map[int]struct {
			result1 v1.PermissionsService_ReadRelationshipsClient
			result2 error
		})
	}
	fake.readRelationshipsReturnsOnCall[i] = struct {
		result1 v1.PermissionsService_ReadRelationshipsClient
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ReadSchema(arg1 context.Context, arg2 *v1.ReadSchemaRequest, arg3 ...grpc.CallOption) (*v1.ReadSchemaResponse, error) {
	fake.readSchemaMutex.Lock()
	ret, specificReturn := fake.readSchemaReturnsOnCall[len(fake.readSchemaArgsForCall)]
	fake.readSchemaArgsForCall = append(fake.readSchemaArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.ReadSchemaRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.ReadSchemaStub
	fakeReturns := fake.readSchemaReturns
	fake.recordInvocation("ReadSchema", []interface{}{arg1, arg2, arg3})
	fake.readSchemaMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) ReadSchemaCallCount() int {
	fake.readSchemaMutex.RLock()
	defer fake.readSchemaMutex.RUnlock()
	return len(fake.readSchemaArgsForCall)
}

func (fake *FakeClient) ReadSchemaCalls(stub func(context.Context, *v1.ReadSchemaRequest, ...grpc.CallOption) (*v1.ReadSchemaResponse, error)) {
	fake.readSchemaMutex.Lock()
	defer fake.readSchemaMutex.Unlock()
	fake.ReadSchemaStub = stub
}

func (fake *FakeClient) ReadSchemaArgsForCall(i int) (context.Context, *v1.ReadSchemaRequest, []grpc.CallOption) {
	fake.readSchemaMutex.RLock()
	defer fake.readSchemaMutex.RUnlock()
	argsForCall := fake.readSchemaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) ReadSchemaReturns(result1 *v1.ReadSchemaResponse, result2 error) {
	fake.readSchemaMutex.Lock()
	defer fake.readSchemaMutex.Unlock()
	fake.ReadSchemaStub = nil
	fake.readSchemaReturns = struct {
		result1 *v1.ReadSchemaResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) ReadSchemaReturnsOnCall(i int, result1 *v1.ReadSchemaResponse, result2 error) {
	fake.readSchemaMutex.Lock()
	defer fake.readSchemaMutex.Unlock()
	fake.ReadSchemaStub = nil
	if fake.readSchemaReturnsOnCall == nil {
		fake.readSchemaReturnsOnCall = make(map[int]struct {
			result1 *v1.ReadSchemaResponse
			result2 error
		})
	}
	fake.readSchemaReturnsOnCall[i] = struct {
		result1 *v1.ReadSchemaResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Watch(arg1 context.Context, arg2 *v1.WatchRequest, arg3 ...grpc.CallOption) (v1.WatchService_WatchClient, error) {
	fake.watchMutex.Lock()
	ret, specificReturn := fake.watchReturnsOnCall[len(fake.watchArgsForCall)]
	fake.watchArgsForCall = append(fake.watchArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.WatchRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.WatchStub
	fakeReturns := fake.watchReturns
	fake.recordInvocation("Watch", []interface{}{arg1, arg2, arg3})
	fake.watchMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) WatchCallCount() int {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	return len(fake.watchArgsForCall)
}

func (fake *FakeClient) WatchCalls(stub func(context.Context, *v1.WatchRequest, ...grpc.CallOption) (v1.WatchService_WatchClient, error)) {
	fake.watchMutex.Lock()
	defer fake.watchMutex.Unlock()
	fake.WatchStub = stub
}

func (fake *FakeClient) WatchArgsForCall(i int) (context.Context, *v1.WatchRequest, []grpc.CallOption) {
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	argsForCall := fake.watchArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) WatchReturns(result1 v1.WatchService_WatchClient, result2 error) {
	fake.watchMutex.Lock()
	defer fake.watchMutex.Unlock()
	fake.WatchStub = nil
	fake.watchReturns = struct {
		result1 v1.WatchService_WatchClient
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) WatchReturnsOnCall(i int, result1 v1.WatchService_WatchClient, result2 error) {
	fake.watchMutex.Lock()
	defer fake.watchMutex.Unlock()
	fake.WatchStub = nil
	if fake.watchReturnsOnCall == nil {
		fake.watchReturnsOnCall = make(map[int]struct {
			result1 v1.WatchService_WatchClient
			result2 error
		})
	}
	fake.watchReturnsOnCall[i] = struct {
		result1 v1.WatchService_WatchClient
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) WriteRelationships(arg1 context.Context, arg2 *v1.WriteRelationshipsRequest, arg3 ...grpc.CallOption) (*v1.WriteRelationshipsResponse, error) {
	fake.writeRelationshipsMutex.Lock()
	ret, specificReturn := fake.writeRelationshipsReturnsOnCall[len(fake.writeRelationshipsArgsForCall)]
	fake.writeRelationshipsArgsForCall = append(fake.writeRelationshipsArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.WriteRelationshipsRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.WriteRelationshipsStub
	fakeReturns := fake.writeRelationshipsReturns
	fake.recordInvocation("WriteRelationships", []interface{}{arg1, arg2, arg3})
	fake.writeRelationshipsMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) WriteRelationshipsCallCount() int {
	fake.writeRelationshipsMutex.RLock()
	defer fake.writeRelationshipsMutex.RUnlock()
	return len(fake.writeRelationshipsArgsForCall)
}

func (fake *FakeClient) WriteRelationshipsCalls(stub func(context.Context, *v1.WriteRelationshipsRequest, ...grpc.CallOption) (*v1.WriteRelationshipsResponse, error)) {
	fake.writeRelationshipsMutex.Lock()
	defer fake.writeRelationshipsMutex.Unlock()
	fake.WriteRelationshipsStub = stub
}

func (fake *FakeClient) WriteRelationshipsArgsForCall(i int) (context.Context, *v1.WriteRelationshipsRequest, []grpc.CallOption) {
	fake.writeRelationshipsMutex.RLock()
	defer fake.writeRelationshipsMutex.RUnlock()
	argsForCall := fake.writeRelationshipsArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) WriteRelationshipsReturns(result1 *v1.WriteRelationshipsResponse, result2 error) {
	fake.writeRelationshipsMutex.Lock()
	defer fake.writeRelationshipsMutex.Unlock()
	fake.WriteRelationshipsStub = nil
	fake.writeRelationshipsReturns = struct {
		result1 *v1.WriteRelationshipsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) WriteRelationshipsReturnsOnCall(i int, result1 *v1.WriteRelationshipsResponse, result2 error) {
	fake.writeRelationshipsMutex.Lock()
	defer fake.writeRelationshipsMutex.Unlock()
	fake.WriteRelationshipsStub = nil
	if fake.writeRelationshipsReturnsOnCall == nil {
		fake.writeRelationshipsReturnsOnCall = make(map[int]struct {
			result1 *v1.WriteRelationshipsResponse
			result2 error
		})
	}
	fake.writeRelationshipsReturnsOnCall[i] = struct {
		result1 *v1.WriteRelationshipsResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) WriteSchema(arg1 context.Context, arg2 *v1.WriteSchemaRequest, arg3 ...grpc.CallOption) (*v1.WriteSchemaResponse, error) {
	fake.writeSchemaMutex.Lock()
	ret, specificReturn := fake.writeSchemaReturnsOnCall[len(fake.writeSchemaArgsForCall)]
	fake.writeSchemaArgsForCall = append(fake.writeSchemaArgsForCall, struct {
		arg1 context.Context
		arg2 *v1.WriteSchemaRequest
		arg3 []grpc.CallOption
	}{arg1, arg2, arg3})
	stub := fake.WriteSchemaStub
	fakeReturns := fake.writeSchemaReturns
	fake.recordInvocation("WriteSchema", []interface{}{arg1, arg2, arg3})
	fake.writeSchemaMutex.Unlock()
	if stub != nil {
		return stub(arg1, arg2, arg3...)
	}
	if specificReturn {
		return ret.result1, ret.result2
	}
	return fakeReturns.result1, fakeReturns.result2
}

func (fake *FakeClient) WriteSchemaCallCount() int {
	fake.writeSchemaMutex.RLock()
	defer fake.writeSchemaMutex.RUnlock()
	return len(fake.writeSchemaArgsForCall)
}

func (fake *FakeClient) WriteSchemaCalls(stub func(context.Context, *v1.WriteSchemaRequest, ...grpc.CallOption) (*v1.WriteSchemaResponse, error)) {
	fake.writeSchemaMutex.Lock()
	defer fake.writeSchemaMutex.Unlock()
	fake.WriteSchemaStub = stub
}

func (fake *FakeClient) WriteSchemaArgsForCall(i int) (context.Context, *v1.WriteSchemaRequest, []grpc.CallOption) {
	fake.writeSchemaMutex.RLock()
	defer fake.writeSchemaMutex.RUnlock()
	argsForCall := fake.writeSchemaArgsForCall[i]
	return argsForCall.arg1, argsForCall.arg2, argsForCall.arg3
}

func (fake *FakeClient) WriteSchemaReturns(result1 *v1.WriteSchemaResponse, result2 error) {
	fake.writeSchemaMutex.Lock()
	defer fake.writeSchemaMutex.Unlock()
	fake.WriteSchemaStub = nil
	fake.writeSchemaReturns = struct {
		result1 *v1.WriteSchemaResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) WriteSchemaReturnsOnCall(i int, result1 *v1.WriteSchemaResponse, result2 error) {
	fake.writeSchemaMutex.Lock()
	defer fake.writeSchemaMutex.Unlock()
	fake.WriteSchemaStub = nil
	if fake.writeSchemaReturnsOnCall == nil {
		fake.writeSchemaReturnsOnCall = make(map[int]struct {
			result1 *v1.WriteSchemaResponse
			result2 error
		})
	}
	fake.writeSchemaReturnsOnCall[i] = struct {
		result1 *v1.WriteSchemaResponse
		result2 error
	}{result1, result2}
}

func (fake *FakeClient) Invocations() map[string][][]interface{} {
	fake.invocationsMutex.RLock()
	defer fake.invocationsMutex.RUnlock()
	fake.checkPermissionMutex.RLock()
	defer fake.checkPermissionMutex.RUnlock()
	fake.deleteRelationshipsMutex.RLock()
	defer fake.deleteRelationshipsMutex.RUnlock()
	fake.expandPermissionTreeMutex.RLock()
	defer fake.expandPermissionTreeMutex.RUnlock()
	fake.lookupResourcesMutex.RLock()
	defer fake.lookupResourcesMutex.RUnlock()
	fake.lookupSubjectsMutex.RLock()
	defer fake.lookupSubjectsMutex.RUnlock()
	fake.readRelationshipsMutex.RLock()
	defer fake.readRelationshipsMutex.RUnlock()
	fake.readSchemaMutex.RLock()
	defer fake.readSchemaMutex.RUnlock()
	fake.watchMutex.RLock()
	defer fake.watchMutex.RUnlock()
	fake.writeRelationshipsMutex.RLock()
	defer fake.writeRelationshipsMutex.RUnlock()
	fake.writeSchemaMutex.RLock()
	defer fake.writeSchemaMutex.RUnlock()
	copiedInvocations := map[string][][]interface{}{}
	for key, value := range fake.invocations {
		copiedInvocations[key] = value
	}
	return copiedInvocations
}

func (fake *FakeClient) recordInvocation(key string, args []interface{}) {
	fake.invocationsMutex.Lock()
	defer fake.invocationsMutex.Unlock()
	if fake.invocations == nil {
		fake.invocations = map[string][][]interface{}{}
	}
	if fake.invocations[key] == nil {
		fake.invocations[key] = [][]interface{}{}
	}
	fake.invocations[key] = append(fake.invocations[key], args)
}

var _ client.Client = new(FakeClient)
